---
description: Specific optimizations for running Agave as a trading bot node
---
# Trading Bot Node Optimization Guide

This guide provides specific optimizations for running Agave as a node optimized for trading bots, focusing on minimal latency, fast synchronization, and efficient resource usage.

## Trading Bot Requirements

1. **Ultra-low latency** for transaction processing
2. **Fast slot synchronization** to stay current with the network
3. **Efficient memory usage** for cost-effective operation
4. **Reliable data access** for accurate trading decisions
5. **Minimal validator overhead** (no voting required)

## Configuration Optimizations

### 1. Validator Configuration
```toml
# validator config
[validator]
# Disable voting (we're not a consensus validator)
no_voting = true

# Skip transaction verification for trusted sources
skip_poh_verify = true

# Optimize for low latency
expected_shred_version = <current_version>

# Reduce snapshot interval
full_snapshot_interval_slots = 50000
incremental_snapshot_interval_slots = 1000

# Limit concurrent connections
max_connections = 500

# Disable non-essential services
enable_rpc_obsolete_v1_7 = false
enable_bigtable_ledger_upload = false
```

### 2. RPC Configuration
```toml
[rpc]
# Enable only required RPC methods
enable_rpc_transaction_history = false
enable_extended_tx_metadata_storage = false

# Optimize for speed
rpc_send_batch_size = 10
rpc_send_batch_ms = 10

# Increase thread count for RPC
rpc_threads = 16
```

### 3. Account Index Configuration
```toml
[account_index]
# Only index accounts we care about
account_indexes = ["spl-token-owner", "spl-token-mint"]

# Exclude vote accounts
exclude_vote_accounts = true
```

## Code-Level Optimizations

### 1. Skip Non-Essential Processing
```rust
// In replay_stage.rs
impl ReplayStage {
    fn process_slots_optimized_for_trading(&self) {
        // Skip reward calculation
        if !self.is_trading_node {
            self.calculate_rewards();
        }
        
        // Fast-path for recent slots
        if slot > self.root_slot + 100 {
            self.process_slot_fast_path(slot);
        }
    }
}
```

### 2. Optimize Account Loading for Trading
```rust
// Preload frequently accessed accounts
pub struct TradingAccountCache {
    // Serum DEX accounts
    serum_markets: FxHashMap<Pubkey, Market>,
    // Token accounts
    token_accounts: FxHashMap<Pubkey, TokenAccount>,
    // User accounts
    user_accounts: LruCache<Pubkey, Account>,
}

impl TradingAccountCache {
    pub fn prefetch_market_accounts(&self, market: &Pubkey) {
        // Prefetch orderbook
        // Prefetch event queue
        // Prefetch request queue
    }
}
```

### 3. Transaction Priority Processing
```rust
// Prioritize trading transactions
pub fn prioritize_transactions(txs: Vec<Transaction>) -> Vec<Transaction> {
    txs.into_iter()
        .sorted_by_key(|tx| {
            // High priority for:
            // - DEX interactions
            // - Token transfers
            // - High fee transactions
            calculate_priority(tx)
        })
        .collect()
}
```

### 4. Optimized Slot Processing
```rust
// Fast slot synchronization
impl SlotProcessor {
    pub fn catch_up_fast(&self, target_slot: Slot) {
        // Skip intermediate slots if too far behind
        if target_slot - self.current_slot > 1000 {
            self.jump_to_slot(target_slot - 10);
        }
        
        // Process only essential data
        self.process_minimal_slot_data(target_slot);
    }
}
```

## Memory Optimization

### 1. Reduce Account Storage
```rust
// Custom account storage for trading
pub struct TradingAccountStorage {
    // Only store accounts modified in last N slots
    recent_accounts: BoundedHashMap<Pubkey, Account>,
    // Compress historical data
    compressed_history: CompressedStorage,
}
```

### 2. Limit Transaction History
```rust
// Keep minimal transaction history
const MAX_TRANSACTION_HISTORY: usize = 1000;
const MAX_SLOT_HISTORY: usize = 100;
```

### 3. Aggressive Garbage Collection
```rust
// More frequent cleanup
impl AccountsDb {
    pub fn aggressive_cleanup(&self) {
        // Clean every 100 slots instead of 1000
        if slot % 100 == 0 {
            self.clean_accounts();
            self.shrink_ancient_storages();
        }
    }
}
```

## Network Optimization

### 1. Peer Selection
```rust
// Connect to high-quality peers
pub fn select_optimal_peers(cluster_info: &ClusterInfo) -> Vec<ContactInfo> {
    cluster_info.all_peers()
        .filter(|peer| {
            // High stake validators
            peer.stake > MIN_PEER_STAKE &&
            // Low latency
            peer.latency < MAX_LATENCY_MS &&
            // Geographically close
            peer.data_center == our_data_center
        })
        .take(MAX_PEERS)
        .collect()
}
```

### 2. Shred Filtering
```rust
// Only process relevant shreds
pub fn filter_shreds_for_trading(shreds: Vec<Shred>) -> Vec<Shred> {
    shreds.into_iter()
        .filter(|shred| {
            // Recent slots only
            shred.slot() > current_slot - 10 &&
            // Skip repair shreds
            !shred.is_repair() &&
            // Data shreds only (skip coding)
            shred.is_data()
        })
        .collect()
}
```

## Monitoring and Alerting

### 1. Critical Metrics
```rust
// Monitor trading-specific metrics
pub fn monitor_trading_health() {
    datapoint_info!("trading_node_health",
        ("slot_behind", get_slot_behind(), i64),
        ("account_cache_hit_rate", get_cache_hit_rate(), f64),
        ("transaction_latency_ms", get_tx_latency(), i64),
        ("memory_usage_gb", get_memory_usage_gb(), f64),
    );
}
```

### 2. Alerting Thresholds
- Slot behind > 5: Warning
- Slot behind > 10: Critical
- Transaction latency > 100ms: Warning
- Memory usage > 80%: Warning

## Deployment Best Practices

### 1. Hardware Recommendations
- **CPU**: High single-thread performance (e.g., AMD Ryzen 9 5950X)
- **RAM**: 64GB minimum, 128GB recommended
- **Storage**: NVMe SSD with >1TB capacity
- **Network**: 10Gbps connection minimum

### 2. OS Tuning
```bash
# Disable CPU frequency scaling
cpupower frequency-set -g performance

# Increase file descriptors
ulimit -n 1000000

# Disable swap
swapoff -a

# Set process priority
nice -n -20 ./agave-validator
```

### 3. Container Optimization
```dockerfile
FROM rust:latest as builder
# Multi-stage build for smaller image
# Compile with optimizations
ENV RUSTFLAGS="-C target-cpu=native -C opt-level=3"

FROM debian:bullseye-slim
# Minimal runtime dependencies
# Run as non-root user
```

## Testing and Validation

### 1. Performance Benchmarks
```rust
#[test]
fn bench_trading_scenario() {
    // Simulate typical trading load
    // Measure transaction latency
    // Check synchronization speed
}
```

### 2. Stress Testing
- Simulate high transaction volume
- Test with degraded network conditions
- Verify behavior when falling behind

### 3. Correctness Validation
- Ensure account states are accurate
- Verify transaction ordering
- Check data consistency

## Rollout Strategy

1. **Start with testnet** deployment
2. **Monitor all metrics** closely
3. **Gradually increase** load
4. **A/B test** optimizations
5. **Have rollback plan** ready

## Common Pitfalls

1. **Over-optimization** - Don't sacrifice correctness
2. **Ignoring edge cases** - Handle network issues gracefully
3. **Memory leaks** - Monitor long-running performance
4. **Stale data** - Ensure cache invalidation works
5. **Network isolation** - Maintain enough peers