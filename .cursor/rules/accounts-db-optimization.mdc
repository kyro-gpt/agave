---
globs: accounts-db/**/*.rs
---
# Accounts Database Performance Optimization

The accounts database is a critical component that manages all account state in the validator. For a trading bot node, optimizing account access patterns is essential for fast transaction processing and state queries.

## Architecture Overview

Key components:
- **AccountsDb** - Main database structure
- **AccountsIndex** - In-memory index of account locations
- **AccountStorage** - Manages append-vec storage files
- **ReadOnlyAccountsCache** - Read cache for frequently accessed accounts
- **AccountsCache** - Write cache for recent modifications

## Major Performance Bottlenecks

### 1. Lock Contention
The accounts database uses extensive locking:
- `Arc<RwLock<T>>` patterns throughout
- Global locks on account updates
- Index lock contention

### 2. Memory Usage
- Large in-memory index
- Multiple cache layers
- Storage file fragmentation

### 3. I/O Operations
- Random access patterns
- Frequent fsync operations
- Storage file management overhead

## Optimization Strategies

### 1. Replace HashMap with FxHashMap
```rust
// In accounts_index.rs
use rustc_hash::FxHashMap;

// Replace
type AccountMap = HashMap<Pubkey, AccountInfo>;
// With
type AccountMap = FxHashMap<Pubkey, AccountInfo>;
```

### 2. Optimize Read Cache
```rust
// In read_only_accounts_cache.rs
impl ReadOnlyAccountsCache {
    // Increase cache size for trading bot use case
    const CACHE_SIZE: usize = 1_000_000; // Increase from default
    
    // Implement LFU instead of LRU for better hit rate
    // Trading bots access same accounts repeatedly
}
```

### 3. Reduce Lock Contention
```rust
// Use sharded locks for account index
use dashmap::DashMap;

// Replace
pub struct AccountsIndex {
    accounts: RwLock<HashMap<Pubkey, AccountInfo>>,
}

// With
pub struct AccountsIndex {
    accounts: DashMap<Pubkey, AccountInfo>,
}
```

### 4. Memory-Mapped Storage
```rust
// In append_vec.rs
use memmap2::{MmapOptions, Mmap};

// Implement zero-copy reads
impl AppendVec {
    pub fn get_account_mmap(&self, offset: usize) -> Result<AccountRef> {
        // Return memory-mapped view instead of copying
    }
}
```

### 5. Batch Operations
```rust
// Batch account loads
pub fn load_accounts_batch(&self, pubkeys: &[Pubkey]) -> Vec<Option<Account>> {
    // Sort pubkeys by storage location
    // Load from same storage file together
    // Minimize file handle operations
}
```

## Storage Optimization

### 1. Reduce Storage Fragmentation
```rust
// Implement better packing algorithm
fn pack_ancient_storages(&self, slot: Slot) {
    // Combine small storages into larger ones
    // Reduce number of open file handles
    // Improve sequential access patterns
}
```

### 2. Async I/O
```rust
// Use io_uring for async I/O operations
#[cfg(target_os = "linux")]
use io_uring::{IoUring, squeue::Entry};

impl AccountStorage {
    async fn load_account_async(&self, location: StorageLocation) -> Result<Account> {
        // Implement async loading
    }
}
```

### 3. Compression
```rust
// Implement account data compression
use lz4::block::{compress, decompress};

fn store_account_compressed(&self, account: &Account) -> Result<()> {
    let compressed = compress(&account.data, None)?;
    // Store compressed data
}
```

## Index Optimization

### 1. Bloom Filters
```rust
// Add bloom filter for existence checks
use bloom::BloomFilter;

struct AccountsIndex {
    bloom: BloomFilter,
    // ... other fields
}

impl AccountsIndex {
    fn contains_key_fast(&self, pubkey: &Pubkey) -> bool {
        // Check bloom filter first
        if !self.bloom.contains(pubkey) {
            return false;
        }
        // Then check actual index
        self.get(pubkey).is_some()
    }
}
```

### 2. Hierarchical Index
```rust
// Implement two-level index for better cache locality
struct HierarchicalIndex {
    // First level: prefix -> second level index
    level1: FxHashMap<u64, Box<SecondLevelIndex>>,
}

struct SecondLevelIndex {
    accounts: FxHashMap<Pubkey, AccountInfo>,
}
```

## Trading Bot Specific Optimizations

### 1. Specialized Account Cache
```rust
// Cache for frequently accessed trading accounts
struct TradingAccountCache {
    // Token accounts
    token_accounts: FxHashMap<Pubkey, Account>,
    // Market accounts  
    market_accounts: FxHashMap<Pubkey, Account>,
    // User accounts
    user_accounts: LruCache<Pubkey, Account>,
}
```

### 2. Prefetching
```rust
// Prefetch accounts likely to be accessed
impl AccountsDb {
    fn prefetch_trading_accounts(&self, market: &Pubkey) {
        // Prefetch orderbook accounts
        // Prefetch common token accounts
        // Warm up cache before trading
    }
}
```

### 3. Skip Non-Essential Operations
```rust
// For trading bot, skip some operations
impl AccountsDb {
    fn store_accounts_fast(&self, accounts: &[(&Pubkey, &Account)]) {
        // Skip rent collection for known accounts
        // Skip some validation for trusted sources
        // Minimize index updates
    }
}
```

## Monitoring and Metrics

### Key Metrics
1. **Cache hit rates** - Should be >90% for trading accounts
2. **Lock wait times** - Monitor contention
3. **Storage I/O latency** - Track read/write performance
4. **Memory usage** - Monitor index and cache sizes

### Profiling Points
```rust
// Add detailed timing
use solana_measure::measure::Measure;

let mut load_time = Measure::start("load_account");
let account = self.load_account(pubkey)?;
load_time.stop();

datapoint_info!("accounts_db_metrics",
    ("load_us", load_time.as_us(), i64),
    ("cache_hit", cache_hit, bool),
);
```

## Testing Strategy

1. **Benchmark Account Operations**
```rust
#[bench]
fn bench_load_account(b: &mut Bencher) {
    let db = setup_test_db();
    b.iter(|| {
        db.load_account(&pubkey)
    });
}
```

2. **Stress Testing**
   - Simulate high account churn
   - Test with millions of accounts
   - Measure performance degradation

3. **Cache Effectiveness**
   - Test various cache strategies
   - Measure hit rates for different workloads
   - Optimize cache size and eviction policies